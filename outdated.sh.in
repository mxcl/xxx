#!/bin/sh
set -e

if [ "$(id -u)" -eq 0 ]; then
  echo "panic: do not run as root" >&2
  exit 1
fi

GUM_BIN="$(command -v gum 2>/dev/null || true)"
if [ -n "${GUM_BIN}" ] && ! "${GUM_BIN}" --version >/dev/null 2>&1; then
  GUM_BIN=
fi
OUTDATED_SELF="$0"

case "${OUTDATED_SELF}" in
  */*)
    ;;
  *)
    resolved_self="$(command -v "${OUTDATED_SELF}" 2>/dev/null || true)"
    if [ -n "${resolved_self}" ]; then
      OUTDATED_SELF="${resolved_self}"
    fi
    ;;
esac

if ! [ -x "${OUTDATED_SELF}" ]; then
  resolved_self="$(command -v outdated 2>/dev/null || true)"
  if [ -n "${resolved_self}" ]; then
    OUTDATED_SELF="${resolved_self}"
  fi
fi

gum() {
  if [ -n "${GUM_BIN}" ]; then
    "${GUM_BIN}" "$@"
  fi
}

is_internal_command() {
  case "$1" in
    uv_python_upgrade_available|rustup_upgrade_available|outdated_*|install_*)
      return 0
      ;;
    *)
      return 1
      ;;
  esac
}

is_known_install_target() {
  return 1
}

run_internal() {
  target="${1:-}"
  if [ -z "${target}" ]; then
    echo "panic: missing internal target" >&2
    exit 1
  fi
  shift

  if ! is_internal_command "${target}"; then
    echo "panic: unknown internal target: ${target}" >&2
    exit 1
  fi

  case "${target}" in
    outdated_*|install_*)
      OUTDATED_BOOTSTRAP_ONLY=1
      run_outdated >/dev/null
      ;;
  esac

  "${target}" "$@"
}

run_step() {
  title="$1"
  shift
  command_name="$1"
  shift

  if [ "${command_name}" = "sudo" ]; then
    printf '# %s\n' "${title}" >&2
    "${command_name}" "$@"
    return
  fi

  if is_internal_command "${command_name}"; then
    printf '# %s\n' "${title}" >&2
    "${command_name}" "$@"
    return
  fi

  if [ -n "${GUM_BIN}" ]; then
    gum spin --title "${title}" -- "${command_name}" "$@"
  else
    printf '# %s\n' "${title}" >&2
    "${command_name}" "$@"
  fi
}

run_step_capture() {
  title="$1"
  shift
  command_name="$1"
  shift

  if [ "${command_name}" = "sudo" ]; then
    printf '# %s\n' "${title}" >&2
    "${command_name}" "$@"
    return
  fi

  if is_internal_command "${command_name}"; then
    printf '# %s\n' "${title}" >&2
    "${command_name}" "$@"
    return
  fi

  if [ -n "${GUM_BIN}" ]; then
    gum spin --show-output --title "${title}" -- "${command_name}" "$@"
  else
    printf '# %s\n' "${title}" >&2
    "${command_name}" "$@"
  fi
}

shell_quote() {
  escaped="$(printf '%s' "$1" | /usr/bin/sed "s/'/'\\\\''/g")"
  printf "'%s'" "${escaped}"
}

queue_arg() {
  quoted="$(shell_quote "$1")"
  APPLY_ARGS="${APPLY_ARGS} ${quoted}"
  PLAN_HAS_ACTION=1
}

queue_brew_upgrade() {
  queue_arg "--brew"
}

queue_uv_python_upgrade() {
  queue_arg "--uv-python"
}

queue_rustup_upgrade() {
  queue_arg "--rustup"
}

queue_install() {
  name="$1"
  version="$2"
  if [ -z "${name}" ] || [ -z "${version}" ]; then
    return 0
  fi

  queue_arg "--install"
  queue_arg "${name}=${version}"
}

append_install_spec() {
  if [ -z "${REORDERED_INSTALL_QUEUE}" ]; then
    REORDERED_INSTALL_QUEUE="${1}"
  else
    REORDERED_INSTALL_QUEUE="${REORDERED_INSTALL_QUEUE}
${1}"
  fi
}

reorder_install_queue() {
  if [ -z "${INSTALL_QUEUE}" ]; then
    return 0
  fi

  REORDERED_INSTALL_QUEUE=""

  while IFS= read -r spec; do
    if [ -z "${spec}" ]; then
      continue
    fi
    name="${spec%%=*}"
    if [ "${name}" = "yoink" ]; then
      append_install_spec "${spec}"
    fi
  done <<EOF
${INSTALL_QUEUE}
EOF

  while IFS= read -r spec; do
    if [ -z "${spec}" ]; then
      continue
    fi
    name="${spec%%=*}"
    if [ "${name}" = "deno" ]; then
      append_install_spec "${spec}"
    fi
  done <<EOF
${INSTALL_QUEUE}
EOF

  while IFS= read -r spec; do
    if [ -z "${spec}" ]; then
      continue
    fi
    name="${spec%%=*}"
    if [ "${name}" = "uv" ]; then
      append_install_spec "${spec}"
    fi
  done <<EOF
${INSTALL_QUEUE}
EOF

  while IFS= read -r spec; do
    if [ -z "${spec}" ]; then
      continue
    fi
    name="${spec%%=*}"
    if [ "${name}" = "aws" ]; then
      append_install_spec "${spec}"
    fi
  done <<EOF
${INSTALL_QUEUE}
EOF

  while IFS= read -r spec; do
    if [ -z "${spec}" ]; then
      continue
    fi
    name="${spec%%=*}"
    case "${name}" in
      yoink|deno|uv|aws)
        continue
        ;;
    esac
    append_install_spec "${spec}"
  done <<EOF
${INSTALL_QUEUE}
EOF

  INSTALL_QUEUE="${REORDERED_INSTALL_QUEUE}"
}

emit_plan() {
  if [ "${PLAN_HAS_ACTION}" -eq 0 ]; then
    return 0
  fi

  printf 'outdated --apply%s\n' "${APPLY_ARGS}"
}

begin_root_script() {
  ROOT_SCRIPT="${UPGRADE_STAGE_DIR}/root.sh"
  cat >"${ROOT_SCRIPT}" <<'EOF'
#!/bin/sh
set -e

apply_root_updates() {
EOF
  ROOT_COMMANDS_QUEUED=0
}

emit_root() {
  ROOT_COMMANDS_QUEUED=1

  sep=""
  printf '  ' >>"${ROOT_SCRIPT}"
  for arg in "$@"; do
    escaped="$(printf '%s' "${arg}" | /usr/bin/sed "s/'/'\\\\''/g")"
    printf "%s'%s'" "${sep}" "${escaped}" >>"${ROOT_SCRIPT}"
    sep=" "
  done
  printf '\n' >>"${ROOT_SCRIPT}"
}

apply_root_commands() {
  cat >>"${ROOT_SCRIPT}" <<'EOF'
}

apply_root_updates "$@"
EOF

  chmod 700 "${ROOT_SCRIPT}"

  if [ "${ROOT_COMMANDS_QUEUED}" -eq 0 ]; then
    return 0
  fi

  run_step "Applying privileged updates" sudo "${ROOT_SCRIPT}"
}

max_version() {
  best=""
  while IFS= read -r candidate; do
    if [ -z "${candidate}" ]; then
      continue
    fi
    if [ -z "${best}" ] || template_version_is_newer "${candidate}" "${best}"; then
      best="${candidate}"
    fi
  done
  printf '%s\n' "${best}"
}

template_sanitize_version() {
  printf '%s' "$1" | /usr/bin/sed -E 's/^[^0-9]*//; s/[^0-9.].*$//'
}

template_version_is_newer() {
  latest="$(template_sanitize_version "$1")"
  current="$(template_sanitize_version "$2")"

  if [ -z "${latest}" ] || [ -z "${current}" ]; then
    return 0
  fi

  /usr/bin/awk -v a="${latest}" -v b="${current}" '
    function splitver(v, arr,    i, n) {
      n = split(v, arr, ".");
      for (i = 1; i <= n; i++) if (arr[i] == "") arr[i] = 0;
      return n;
    }
    BEGIN {
      na = splitver(a, A);
      nb = splitver(b, B);
      n = (na > nb) ? na : nb;
      for (i = 1; i <= n; i++) {
        ai = (i <= na) ? A[i] : 0;
        bi = (i <= nb) ? B[i] : 0;
        if (ai + 0 > bi + 0) exit 0;
        if (ai + 0 < bi + 0) exit 1;
      }
      exit 2;
    }'

  case $? in
    0) return 0 ;;
    *) return 1 ;;
  esac
}

uv_python_upgrade_available() {
  if ! [ -x "/usr/local/bin/uv" ]; then
    return 1
  fi

  if ! command -v /usr/bin/jq >/dev/null 2>&1; then
    return 0
  fi

  installed_json="$(
    /usr/local/bin/uv python list --only-installed --output-format json \
      2>/dev/null || true
  )"
  if [ -z "${installed_json}" ] || [ "${installed_json}" = "[]" ]; then
    return 1
  fi

  minors="$(
    printf '%s' "${installed_json}" |
      /usr/bin/jq -r '
        .[] |
        select(.implementation == "cpython") |
        select(.path != null and (.path | contains("/.local/share/uv/python/"))) |
        "\(.version_parts.major).\(.version_parts.minor)"
      ' 2>/dev/null |
      /usr/bin/sort -u
  )"

  if [ -z "${minors}" ]; then
    return 1
  fi

  for minor in ${minors}; do
    installed_versions="$(
      printf '%s' "${installed_json}" |
        /usr/bin/jq -r --arg minor "${minor}" '
          .[] |
          select(.implementation == "cpython") |
          select(.path != null and (.path | contains("/.local/share/uv/python/"))) |
          select(
            ((.version_parts.major | tostring) + "." +
            (.version_parts.minor | tostring)) == $minor
          ) |
          .version
        ' 2>/dev/null
    )"
    current="$(printf '%s\n' "${installed_versions}" | max_version)"
    if [ -z "${current}" ]; then
      continue
    fi

    available_json="$(
      /usr/local/bin/uv python list "${minor}" --only-downloads --output-format \
        json 2>/dev/null || true
    )"
    if [ -z "${available_json}" ] || [ "${available_json}" = "[]" ]; then
      continue
    fi

    available_versions="$(
      printf '%s' "${available_json}" |
        /usr/bin/jq -r --arg minor "${minor}" '
          .[] |
          select(.implementation == "cpython") |
          select(
            ((.version_parts.major | tostring) + "." +
            (.version_parts.minor | tostring)) == $minor
          ) |
          .version
        ' 2>/dev/null
    )"
    latest="$(printf '%s\n' "${available_versions}" | max_version)"

    if [ -n "${latest}" ] && template_version_is_newer "${latest}" "${current}"; then
      return 0
    fi
  done

  return 1
}

rustup_upgrade_available() {
  if ! [ -x "$HOME/.cargo/bin/rustup" ]; then
    return 1
  fi

  if "$HOME/.cargo/bin/rustup" check 2>/dev/null |
    /usr/bin/grep -q "Update available"
  then
    return 0
  fi

  return 1
}

run_apply() {
  APPLY_BREW=0
  APPLY_UV_PYTHON=0
  APPLY_RUSTUP=0
  INSTALL_QUEUE=""

  while [ $# -gt 0 ]; do
    case "$1" in
      --brew)
        APPLY_BREW=1
        ;;
      --uv-python)
        APPLY_UV_PYTHON=1
        ;;
      --rustup)
        APPLY_RUSTUP=1
        ;;
      --install)
        shift
        if [ $# -eq 0 ]; then
          echo "panic: --install requires NAME=VERSION" >&2
          exit 1
        fi
        if [ -z "${INSTALL_QUEUE}" ]; then
          INSTALL_QUEUE="$1"
        else
          INSTALL_QUEUE="${INSTALL_QUEUE}
$1"
        fi
        ;;
      *)
        echo "panic: unknown apply argument: $1" >&2
        exit 1
        ;;
    esac
    shift
  done

  UPGRADE_STAGE_DIR="$(mktemp -d "${TMPDIR:-/tmp}/upgrade.XXXXXX")"
  if ! [ -d "${UPGRADE_STAGE_DIR}" ]; then
    echo "panic: failed to create staging directory" >&2
    exit 1
  fi
  trap 'rm -rf "${UPGRADE_STAGE_DIR}"' EXIT

  run_step "Staging in ${UPGRADE_STAGE_DIR}" true
  begin_root_script
  _SUDO=emit_root

  if [ "${APPLY_BREW}" -eq 1 ] && [ -x "/opt/homebrew/bin/brew" ]; then
    run_step "Updating Homebrew" /opt/homebrew/bin/brew upgrade
  fi

  if [ "${APPLY_UV_PYTHON}" -eq 1 ] && [ -x "/usr/local/bin/uv" ]; then
    run_step "Updating Pythons" /usr/local/bin/uv python upgrade
  fi

  if [ "${APPLY_RUSTUP}" -eq 1 ] && [ -x "$HOME/.cargo/bin/rustup" ]; then
    run_step "Updating Rust" "$HOME/.cargo/bin/rustup" update
  fi

  if [ -n "${INSTALL_QUEUE}" ]; then
    reorder_install_queue

    while IFS= read -r spec; do
      if [ -z "${spec}" ]; then
        continue
      fi

      name="${spec%%=*}"
      version="${spec#*=}"
      if [ -z "${name}" ] || [ "${name}" = "${spec}" ] || [ -z "${version}" ]; then
        echo "panic: invalid install spec: ${spec}" >&2
        exit 1
      fi

      case "${name}" in
        *[!A-Za-z0-9_]*)
          echo "panic: invalid install target: ${name}" >&2
          exit 1
          ;;
      esac

      if ! is_known_install_target "${name}"; then
        echo "panic: unknown install target: ${name}" >&2
        exit 1
      fi

      install_func="install_${name}"
      run_step "Updating ${name}" "${install_func}" "${version}"
    done <<EOF
${INSTALL_QUEUE}
EOF
  fi

  apply_root_commands
}

run_outdated() {
  APPLY_ARGS=""
  PLAN_HAS_ACTION=0

  if [ "${OUTDATED_BOOTSTRAP_ONLY:-0}" -ne 1 ]; then
    if [ -x "/opt/homebrew/bin/brew" ]; then
      if run_step "Checking Homebrew" /bin/sh -c \
        '[ -n "$(/opt/homebrew/bin/brew outdated 2>/dev/null)" ]'
      then
        queue_brew_upgrade
      fi
    fi

    if [ -x "/usr/local/bin/uv" ]; then
      if run_step "Checking Pythons" uv_python_upgrade_available; then
        queue_uv_python_upgrade
      fi
    fi

    if [ -x "$HOME/.cargo/bin/rustup" ]; then
      if run_step "Checking Rust" rustup_upgrade_available; then
        queue_rustup_upgrade
      fi
    fi
  fi
